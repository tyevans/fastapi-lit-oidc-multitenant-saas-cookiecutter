{%- if cookiecutter.include_github_actions == "yes" and cookiecutter.include_kubernetes == "yes" %}
# Deployment Workflow for {{ cookiecutter.project_name }}
# Generated by cookiecutter template
#
# This workflow deploys the application to Kubernetes environments using Kustomize.
#
# Triggers:
# - Automatic staging deployment after successful Build workflow on main
# - Production deployment on version tags (v*)
# - Manual deployment via workflow_dispatch
#
# Features:
# - Staging auto-deploy on push to main (after successful build)
# - Production manual approval via GitHub Environments
# - Kustomize-based image tag updates
# - Deployment verification with health checks
# - Rollback procedures documented
#
# Prerequisites:
# - Configure GitHub Environment secrets: KUBECONFIG_STAGING, KUBECONFIG_PRODUCTION
# - Configure GitHub Environment protection rules for production
# - Ensure Kubernetes cluster has required resources (see k8s/README.md)

name: Deploy

on:
  # Automatic staging deployment after successful build
  workflow_run:
    workflows: ["Build"]
    types:
      - completed
    branches: [main]

  # Manual deployment trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      image_tag:
        description: 'Image tag to deploy (default: uses latest for staging, version for production)'
        required: false
        default: ''
      skip_verification:
        description: 'Skip post-deployment verification'
        required: false
        type: boolean
        default: false

  # Production deployment on version tags
  push:
    tags:
      - 'v*'

# Prevent concurrent deployments to the same environment
concurrency:
  group: deploy-{% raw %}${{ github.event.inputs.environment || (github.ref_type == 'tag' && 'production' || 'staging') }}{% endraw %}
  cancel-in-progress: false  # Don't cancel in-progress deployments

env:
  REGISTRY: ghcr.io
  BACKEND_IMAGE: {% raw %}${{ github.repository }}/backend{% endraw %}
  FRONTEND_IMAGE: {% raw %}${{ github.repository }}/frontend{% endraw %}
  KUBECTL_VERSION: 'v1.29.0'
  NAMESPACE: {{ cookiecutter.project_slug }}

jobs:
  # Determine deployment parameters based on trigger type
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: {% raw %}${{ steps.config.outputs.environment }}{% endraw %}
      image_tag: {% raw %}${{ steps.config.outputs.image_tag }}{% endraw %}
      should_deploy: {% raw %}${{ steps.config.outputs.should_deploy }}{% endraw %}
      sha_short: {% raw %}${{ steps.config.outputs.sha_short }}{% endraw %}
    steps:
      - name: Determine deployment configuration
        id: config
        run: |
          SHA_SHORT="${GITHUB_SHA:0:7}"
          echo "sha_short=$SHA_SHORT" >> $GITHUB_OUTPUT

          # Determine environment and image tag based on trigger type
          if [[ "{% raw %}${{ github.event_name }}{% endraw %}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="{% raw %}${{ github.event.inputs.environment }}{% endraw %}"
            IMAGE_TAG="{% raw %}${{ github.event.inputs.image_tag }}{% endraw %}"

            # Default image tag based on environment if not provided
            if [[ -z "$IMAGE_TAG" ]]; then
              if [[ "$ENVIRONMENT" == "production" ]]; then
                echo "::error::Image tag is required for production deployments"
                exit 1
              else
                IMAGE_TAG="latest"
              fi
            fi

            echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
            echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT

          elif [[ "{% raw %}${{ github.ref_type }}{% endraw %}" == "tag" ]]; then
            # Production deployment triggered by version tag
            VERSION="${GITHUB_REF_NAME#v}"
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "image_tag=$VERSION" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT

          elif [[ "{% raw %}${{ github.event.workflow_run.conclusion }}{% endraw %}" == "success" ]]; then
            # Staging deployment triggered by successful build
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT

          else
            # Build failed or other trigger - skip deployment
            echo "should_deploy=false" >> $GITHUB_OUTPUT
            echo "::notice::Skipping deployment - Build workflow did not succeed"
          fi

      - name: Display deployment configuration
        if: steps.config.outputs.should_deploy == 'true'
        run: |
          echo "## Deployment Configuration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | {% raw %}${{ steps.config.outputs.environment }}{% endraw %} |" >> $GITHUB_STEP_SUMMARY
          echo "| Image Tag | {% raw %}${{ steps.config.outputs.image_tag }}{% endraw %} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit SHA | {% raw %}${{ steps.config.outputs.sha_short }}{% endraw %} |" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | {% raw %}${{ github.event_name }}{% endraw %} |" >> $GITHUB_STEP_SUMMARY

  # Deploy to staging environment (auto-deploy, no approval required)
  deploy-staging:
    name: Deploy to Staging
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true' && needs.prepare.outputs.environment == 'staging'
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.example.com
    permissions:
      contents: read
      id-token: write  # For OIDC authentication to cloud providers
      deployments: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: {% raw %}${{ env.KUBECTL_VERSION }}{% endraw %}

      - name: Configure Kubernetes credentials
        # Using kubeconfig from secret - alternative cloud provider OIDC configs below
        run: |
          mkdir -p ~/.kube
          echo "{% raw %}${{ secrets.KUBECONFIG_STAGING }}{% endraw %}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

          # Verify cluster connectivity
          kubectl cluster-info
          kubectl get nodes --no-headers | head -3
        #
        # Alternative: AWS EKS OIDC authentication
        # - uses: aws-actions/configure-aws-credentials@v4
        #   with:
        #     role-to-assume: {% raw %}${{ secrets.AWS_ROLE_ARN_STAGING }}{% endraw %}
        #     aws-region: us-east-1
        # - run: aws eks update-kubeconfig --name staging-cluster --region us-east-1
        #
        # Alternative: Google GKE OIDC authentication
        # - uses: google-github-actions/auth@v2
        #   with:
        #     workload_identity_provider: {% raw %}${{ secrets.GCP_WORKLOAD_IDENTITY_STAGING }}{% endraw %}
        #     service_account: {% raw %}${{ secrets.GCP_SERVICE_ACCOUNT_STAGING }}{% endraw %}
        # - uses: google-github-actions/get-gke-credentials@v2
        #   with:
        #     cluster_name: staging-cluster
        #     location: us-central1

      - name: Update image tags with Kustomize
        run: |
          cd k8s/overlays/staging

          # Update backend image tag
          kustomize edit set image \
            ghcr.io/{{ cookiecutter.github_username }}/{{ cookiecutter.project_slug }}-backend={% raw %}${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ needs.prepare.outputs.image_tag }}{% endraw %}

          # Update frontend image tag
          kustomize edit set image \
            ghcr.io/{{ cookiecutter.github_username }}/{{ cookiecutter.project_slug }}-frontend={% raw %}${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ needs.prepare.outputs.image_tag }}{% endraw %}

          echo "## Image Tags Updated" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`yaml" >> $GITHUB_STEP_SUMMARY
          grep -A 10 "images:" kustomization.yaml >> $GITHUB_STEP_SUMMARY || true
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Preview deployment changes
        run: |
          echo "## Deployment Preview" >> $GITHUB_STEP_SUMMARY
          echo "Resources to be deployed:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl kustomize k8s/overlays/staging | grep -E "^kind:|^  name:" | head -40 >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Deploy to staging
        run: |
          echo "Deploying to staging environment..."

          # Apply manifests
          kubectl apply -k k8s/overlays/staging

          # Wait for backend rollout
          echo "Waiting for backend deployment rollout..."
          kubectl rollout status deployment/backend \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            --timeout=5m

          # Wait for frontend rollout
          echo "Waiting for frontend deployment rollout..."
          kubectl rollout status deployment/frontend \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            --timeout=5m

      - name: Verify deployment
        if: {% raw %}${{ github.event.inputs.skip_verification != 'true' }}{% endraw %}
        run: |
          echo "## Deployment Verification" >> $GITHUB_STEP_SUMMARY

          # Wait for pods to be ready
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name={{ cookiecutter.project_slug }} \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            --timeout=120s

          # Get pod status
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n {% raw %}${{ env.NAMESPACE }}{% endraw %} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # Check backend health endpoint
          BACKEND_POD=$(kubectl get pod \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            -l app.kubernetes.io/component=backend \
            -o jsonpath='{.items[0].metadata.name}')

          echo "Checking backend health endpoint on pod: $BACKEND_POD"
          kubectl exec -n {% raw %}${{ env.NAMESPACE }}{% endraw %} "$BACKEND_POD" -- \
            curl -sf http://localhost:8000{{ cookiecutter.backend_api_prefix }}/health

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Health Check: PASSED" >> $GITHUB_STEP_SUMMARY

      - name: Get deployment info
        if: always()
        run: |
          echo "### Deployed Images" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            -o jsonpath='{range .items[*]}{.metadata.name}: {.spec.containers[*].image}{"\n"}{end}' >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Create deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '{% raw %}${{ job.status }}{% endraw %}' === 'success' ? 'success' : 'failure';
            const description = status === 'success'
              ? `Deployed {% raw %}${{ needs.prepare.outputs.image_tag }}{% endraw %} to staging`
              : `Deployment failed for {% raw %}${{ needs.prepare.outputs.image_tag }}{% endraw %}`;

            try {
              // Create a deployment status check
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                state: status,
                context: 'deployment/staging',
                description: description,
                target_url: `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
            } catch (error) {
              console.log('Could not create commit status:', error.message);
            }

  # Deploy to production environment (requires manual approval via GitHub Environment)
  deploy-production:
    name: Deploy to Production
    needs: prepare
    if: needs.prepare.outputs.should_deploy == 'true' && needs.prepare.outputs.environment == 'production'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://app.example.com
    permissions:
      contents: write  # For creating releases
      id-token: write
      deployments: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: {% raw %}${{ env.KUBECTL_VERSION }}{% endraw %}

      - name: Configure Kubernetes credentials
        run: |
          mkdir -p ~/.kube
          echo "{% raw %}${{ secrets.KUBECONFIG_PRODUCTION }}{% endraw %}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

          # Verify cluster connectivity
          kubectl cluster-info
          kubectl get nodes --no-headers | head -3

      - name: Update image tags with Kustomize
        run: |
          cd k8s/overlays/production

          # Update backend image tag
          kustomize edit set image \
            ghcr.io/{{ cookiecutter.github_username }}/{{ cookiecutter.project_slug }}-backend={% raw %}${{ env.REGISTRY }}/${{ env.BACKEND_IMAGE }}:${{ needs.prepare.outputs.image_tag }}{% endraw %}

          # Update frontend image tag
          kustomize edit set image \
            ghcr.io/{{ cookiecutter.github_username }}/{{ cookiecutter.project_slug }}-frontend={% raw %}${{ env.REGISTRY }}/${{ env.FRONTEND_IMAGE }}:${{ needs.prepare.outputs.image_tag }}{% endraw %}

          echo "## Image Tags Updated" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`yaml" >> $GITHUB_STEP_SUMMARY
          grep -A 10 "images:" kustomization.yaml >> $GITHUB_STEP_SUMMARY || true
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Preview deployment changes
        run: |
          echo "## Production Deployment Preview" >> $GITHUB_STEP_SUMMARY
          echo "Resources to be deployed:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl kustomize k8s/overlays/production | grep -E "^kind:|^  name:" | head -40 >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Deploy to production
        run: |
          echo "Deploying to production environment..."

          # Apply manifests
          kubectl apply -k k8s/overlays/production

          # Wait for backend rollout
          echo "Waiting for backend deployment rollout..."
          kubectl rollout status deployment/backend \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            --timeout=5m

          # Wait for frontend rollout
          echo "Waiting for frontend deployment rollout..."
          kubectl rollout status deployment/frontend \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            --timeout=5m

      - name: Verify deployment
        if: {% raw %}${{ github.event.inputs.skip_verification != 'true' }}{% endraw %}
        run: |
          echo "## Production Deployment Verification" >> $GITHUB_STEP_SUMMARY

          # Wait for pods to be ready
          echo "Waiting for pods to be ready..."
          kubectl wait --for=condition=ready pod \
            -l app.kubernetes.io/name={{ cookiecutter.project_slug }} \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            --timeout=120s

          # Get pod status
          echo "### Pod Status" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n {% raw %}${{ env.NAMESPACE }}{% endraw %} -o wide >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          # Check backend health endpoint
          BACKEND_POD=$(kubectl get pod \
            -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            -l app.kubernetes.io/component=backend \
            -o jsonpath='{.items[0].metadata.name}')

          echo "Checking backend health endpoint on pod: $BACKEND_POD"
          kubectl exec -n {% raw %}${{ env.NAMESPACE }}{% endraw %} "$BACKEND_POD" -- \
            curl -sf http://localhost:8000{{ cookiecutter.backend_api_prefix }}/health

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Health Check: PASSED" >> $GITHUB_STEP_SUMMARY

      - name: Get deployment info
        if: always()
        run: |
          echo "### Deployed Images" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n {% raw %}${{ env.NAMESPACE }}{% endraw %} \
            -o jsonpath='{range .items[*]}{.metadata.name}: {.spec.containers[*].image}{"\n"}{end}' >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub Release
        if: github.ref_type == 'tag'
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.ref.replace('refs/tags/', '');

            try {
              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: `Release ${tag}`,
                generate_release_notes: true,
                draft: false,
                prerelease: tag.includes('-')  // Mark as prerelease if tag contains hyphen (e.g., v1.0.0-rc1)
              });

              console.log(`Created release for tag ${tag}`);
            } catch (error) {
              if (error.status === 422) {
                console.log(`Release for ${tag} already exists`);
              } else {
                throw error;
              }
            }

      - name: Create deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '{% raw %}${{ job.status }}{% endraw %}' === 'success' ? 'success' : 'failure';
            const description = status === 'success'
              ? `Deployed {% raw %}${{ needs.prepare.outputs.image_tag }}{% endraw %} to production`
              : `Production deployment failed for {% raw %}${{ needs.prepare.outputs.image_tag }}{% endraw %}`;

            try {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.sha,
                state: status,
                context: 'deployment/production',
                description: description,
                target_url: `${process.env.GITHUB_SERVER_URL}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              });
            } catch (error) {
              console.log('Could not create commit status:', error.message);
            }

  # Rollback workflow (manual trigger only)
  rollback:
    name: Rollback Deployment
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: prepare
    environment:
      name: {% raw %}${{ needs.prepare.outputs.environment }}{% endraw %}
    steps:
      - name: Display rollback instructions
        run: |
          echo "## Rollback Instructions" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Quick Rollback (Previous Version)" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Rollback backend" >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout undo deployment/backend -n {{ cookiecutter.project_slug }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Rollback frontend" >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout undo deployment/frontend -n {{ cookiecutter.project_slug }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rollback to Specific Revision" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# List revision history" >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout history deployment/backend -n {{ cookiecutter.project_slug }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Rollback to specific revision" >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout undo deployment/backend -n {{ cookiecutter.project_slug }} --to-revision=2" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rollback via Workflow" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to **Actions** > **Deploy** workflow" >> $GITHUB_STEP_SUMMARY
          echo "2. Click **Run workflow**" >> $GITHUB_STEP_SUMMARY
          echo "3. Select the target environment (staging/production)" >> $GITHUB_STEP_SUMMARY
          echo "4. Enter the specific image tag to roll back to (e.g., \`1.0.0\`)" >> $GITHUB_STEP_SUMMARY
          echo "5. Click **Run workflow**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Verify Rollback" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# Check rollout status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl rollout status deployment/backend -n {{ cookiecutter.project_slug }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Verify current images" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods -n {{ cookiecutter.project_slug }} -o jsonpath='{.items[*].spec.containers[*].image}'" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
{%- endif %}
